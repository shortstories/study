# 6장 동시성

* Communicating Sequential Processes.
* Channel
* Go 런타임 스케쥴러
* 운영체제의 물리적 프로세서, 쓰레드와 go 런타임의 논리적 프로세서, 고루틴으로 나뉘어져 있음.
  * 논리적 프로세서는 하나의 운영체제 쓰레드에 개별적으로 바인딩됨
  * Go 1.5부터는 코어 갯수만큼 논리 프로세서를 생성하고, 그 이전에는 기본적으로 하나의 논리 프로세서만 할당
  * 하나의 논리적 프로세서도 수많은 고루틴을 동시적으로 실행 가능
* 운영체제 쓰레드 - 논리적 프로세서 - local run queue - global run queue - Go 런타임 스케쥴러
* system call이 발생하면 해당 쓰레드랑 고루틴을 묶어서 논리프로세서에서 떼어낸 다음 해당 쓰레드가 system call이 완료되는걸 기다리게끔 만듬. 그리고 논리프로세서에는 새로운 쓰레드와 고루틴을 투입하고 system call이 완료되면 고루틴을 local run queue로 다시 이동, 쓰레드는 다시 사용할 것을 대비해서 풀링. 
* 네트워크 io가 발생하면 고루틴만 분리해서 netpoller로 이동. netpoller가 io 준비 완료를 알리면 다시 고루틴을 논리 프로세서에 할당해서 작업 수행. 

## 동시성 vs 병렬성

* 동시성
  * 서로 독립적으로 실행되고 있는 작업의 집합. 
  * 많은 것들을 어떻게 한번에 다룰 것인가.
  * 설계에 대해서 말하는 것
  * 병렬처리가 필요한 문제가 있을 때, 어떻게 설계할 것인가에 대한 해결책이 될 수 있음
  * 동시성은 하나의 프로그램을 독립적으로 실행되는 여러 조각으로 쪼개서 설계하고 관리하는 방법
  * Communication은 독립적으로 실행되는 각 조각들 사이에서 적절하게 조정하기 위한 방법
* 병렬성
  * 동시에 실행되고 있는 \(가급적 서로 관계있는\) 계산의 집합. 
  * 많은 것들을 어떻게 한번에 실행할 것인가.
  * 실행에 대해서 말하는 것
  * 멀티코어, 네트워크, 클라우드 
* 완전히 같진 않지만 연관된 부분도 있음.
  * 동시성이 병렬이란건 아니다.
  * 동시성은 병렬을 가능하게 만든다.
  * 동시성은 병렬과 스케일링과 그리고 그 모든 것들을 더 쉽게 만들어준다.

## 경쟁 상태

* 둘 이상의 고루틴이 동기화없이 공유된 자원에 접근하여 읽거나 쓰는 경우 발생
* `-race` 옵션을 주고 빌드하면 프로그램을 실행할 때 race condition을 검사하게 만들 수 있음

## 공유자원 잠금

### atomic

* 정수 및 포인터에 대한 접근을 동기화할 수 있는 저 수준의 잠금 메커니즘 제공

### sync

* 뮤텍스 제공
* 세마포어 제공

## 채널

* 고루틴 간에 자원을 공유해야되는 경우 고루틴 사이를 연결하는 파이프처럼 동작
* 데이터 교환에 있어 동기화를 보장
* `channel := make(chan type, bufferSize)`
  * 버퍼의 크기를 지정하거나 생략 가능. 생략할 경우 버퍼가 없는 채널로 생성됨
* 값을 보낼때는 `<-` 연산자 사용 `channel <- data`
* 값을 받을 때도 `<-` 연산자 사용 `value := <- channel`
* unbuffered channel
  * 동기화가 발생. 값 전달 과정에서 전달이 완료될 때 까지 양쪽에 반드시 블로킹 발생
  * 값을 보내고 받는 동작이 반드시 동시에 이루어진다는 것을 보장
  * 데이터가 반드시 교환될 수 있도록 보장
* buffered channel
  * 버퍼가 꽉 찼을 때만 블로킹 발생
  * 채널이 close\(\) 되더라도 버퍼에 남아있는 데이터는 받을 수 있음
  * 버퍼가 비어있고 \(&&\) 채널이 close\(\) 되었을 때만 제로값 또는 상태값 false 반환



