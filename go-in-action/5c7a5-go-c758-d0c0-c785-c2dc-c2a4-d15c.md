# 5장 Go의 타입 시스템

* Go는 정적 타입 프로그래밍 언어
* primitive 타입의 경우 이름에 바이트 크기가 같이 있는 경우가 많음. \(int32, int64 등\)

## 사용자 정의 타입

* c의 struct랑 비슷
* ```go
  type myType struct {
      field1   type1
      field2   type2
  }
  ```
* 변수로 선언하면 모든 필드가 제로값으로 초기화됨

* 제로값이 아니라 특정 값으로 초기화되어야하면 구조체 리터럴 및 변수 선언 연산자 사용

  * ```go
    var1 := myType {
        field1: value1
        field2: value2
    }
    ```
  * `var1 := myType{value1, value2}`
  * 중첩 가능

* primitive 타입을 base type으로 새로운 타입 정의 가능
  * `type Duration int64`
  * base type과 완전히 다른 별개의 타입으로 취급

## Method

* 타입에 행위를 정의하기 위한 방법. func 키워드와 함수 이름 사이에 추가 패러미터를 정의한 함수
* func와 함수 이름 사이의 패러미터는 특별히 receiver이라고 부름
* 그리고 이러한 receiver가 있는 함수는 method라고 지칭
* method의 경우 일반적인 함수의 `Package.Function` 대신에 `Type.Function` 형태로 호출
  * 이 타입이 method의 receiver으로 전달됨.

### Value receiver vs Pointer receiver

* Value receiver
  * `func (n myType) method() {}`
  * receiver의 값을 복사해서 method로 전달함. 따라서 method 내부에서 아무리 변경하더라도 원본에는 영향이 없음.
  * 포인터로도 바로 호출이 가능함. 포인터를 사용해서 method를 호출하면 실질적으로는 `(*myPointer).method()` 와 동일
  * 불변 객체를 유지하고싶다면 Value receiver가 답. 변경이 발생할 때마다 복제본이 반환됨.
* Pointer receiver
  * `func (n *myType) method() {}`
  * receiver의 포인터를 복사해서 method로 전달. 덕분에 method 내부에서 변경하면 원본 인스턴스의 값도 같이 변경됨
  * 값으로도 바로 호출이 가능함. 값을 사용해서 method를 호출하면 `(&myValue).method()` 와 동일
  * 기존 인스턴스의 값을 변경해야한다면 Pointer receiver가 답. 변경이 발생하면 원본이 변경됨.





