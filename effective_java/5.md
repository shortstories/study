# 5장

## Raw type을 쓰지 않기

Raw type은 제네릭 타입에서 매개변수 없이 사용하는 타입을 의미한다. 말하자면 `List` 처럼 뒤에 <> 없이 사용되는 경우라고 말할 수 있다. 간혹 모든 종류의 `List`를 다 사용할 수 있는 메소드를 만들기 위해서 Raw type을 사용하는 경우가 있는데, 그렇게 해서는 안 된다.

그 이유는 다음과 같다.

1. 잘못 사용하고 있어도 컴파일러가 컴파일 에러를 뱉지 않는다.
2. 타입의 안정성을 상실하게 된다.

그 대안으로 Unbounded wildcard type을 사용하자. 이는 `List<?>` 처럼 패러미터에 ?가 들어간 것이다. 이 경우에 어떤 리스트든 받을 수 있지만 리스트의 타입 불변성이 보장된다. 

다만 Raw type을 쓸 수 밖에 없는 상황이 두 가지 있다. 하나는 `List.class`처럼 클래스 리터러시를 쓸 때이고 나머지 하나는 `myObj instanceof List` 처럼 instanceof 연산자를 쓸 때이다. 그 이유는 런타임에선 제너릭 타입의 패러미터 정보가 없어지는 까닭이다. 대신에 instanceof 연산자를 쓰게 되면 Unbounded wildcard type으로 캐스팅하도록 해야한다.

## 컴파일 경고 메세지 줄이기

당연한 소리지만 컴파일 경고 메세지는 없앨 수 있는 만큼 없애야된다. 하지만 부득이하게 줄일 수 없는 케이스가 있다면 다음과 같이 처리한다.

1. 가장 작은 범위로 `@SuppressWarnings()` 사용
2. 이유를 주석이나 문서로 꼭 작성

## 배열보다 `List` 쓰기

### 공변, 불변

배열은 공변이다. 즉 `Parent`, `Child`클래스가 서로 상속관계에 있다면, `Parent[]`, `Child[]`도 서로 캐스팅이 가능하다. 반대로 리스트는 불변이다.

그에 따라 배열은 문제가 생길 수 있는데, 예를 들어 한 부모 아래에 두 자식 클래스가 있고, 서로 호환이 안 되는 경우이다.

``` java
Object[] objArr = new Long[1];
objArr[0] = "wrong"; // ArrayStoreException 발생
```

위와 같은 예제에서 우리는 런타임까지 가서야 잘못되었다는 것을 알 수 있다.

``` java
List<Object> objList = new List<Long>(1); // 컴파일 에러 발생
```

반면에 리스트를 사용하면 컴파일 단계에서 그런 문제를 막아준다.

