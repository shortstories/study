# 7장 - Method

## validation을 꼭 하기

1. public 메소드라면 검사하여 적절한 `Exception`을 던지도록 구현한다. 그리고 문서에다가 관련된 사항들을 기입해야한다.
2. public이 아닌 메소드라면 `assert` 를 사용해서 검사하는 것이 권장된다.
3. 검사 자체의 비용이 아주 비싸거나 메소드 실행 가운데 \(메소드 실행 앞 부분이나 다 끝난 다음이 아니라\) 묵시적으로 검사를 실행하고 있다면 생략할 수 있다.

## 필요하다면 방어복사본 만들기

의도는 불변객체를 만드는 것이지만 그 객체의 필드 중에 가변 객체가 있다면 의도치않게 수정이 가능해지는 경우가 있다. 이러한 경우를 막기 위해서 필요하다면 불변객체를 생성할 때 그 필드에다가 원본 객체 대신에 그 객체의 값을 복사한 새로운 객체를 만들어서 할당해야한다.

### 주의사항

1. validation을 하기 전에 미리 복사본을 만들고, 그 복사본을 바탕으로 validation을 진행해야한다. 왜냐하면 값을 검사하고 나서 복제를 하게 되면 검사가 완료되고 복제를 하려고하는 그 사이 시간에 값을 변경하는 것이 가능하기 때문이다. 
2. `clone` 메소드가 악의적으로 설계된 서브 클래스의 인스턴스를 반환할 수 있기 때문에 `clone` 메소드를 믿으면 안 된다.
3. getter에서도 필드 인스턴스의 복사본을 만들어서 반환하도록 해야 한다. 여기서 차이점은 `clone` 를 써도 된다는 점이다. 왜냐하면 이미 생성 시점에서 검사 완료하고 안전한 인스턴스를 만들어서 넣어두었기 때문이다.
4. 방어복사본을 만드는 것이 성능적으로 불리하므로 내부적으로 안전한 환경이라면 문서화를 적절히 하고 복사본을 쓰는 것을 생략할 수도 있다.

## API 설계 힌트

1. 메소드 이름을 신중하게 짓기. 1차 목표는 일관성 2차 목표는 누가 봐도 이해가 가도록.
2. 너무 많은 메소드를 만들지 않기. 메소드의 갯수는 클래스의 학습 난이도, 문서화 난이도, 테스트 난이도 등을 모두 높인다. 올지도 모르는 미래에 조금 더 편리하게 만들겠다고 필요없는 메소드까지 추가하는 일을 막아야 한다. 필요하다면 약식 메소드를 고려하자.
3. 너무 많은 패러미터 만들지 않기. 가급적 패러미터는 4개 이하를 유지하도록.
   1. 메소드 쪼개기. 가급적 직교성을 고려하여 쪼개도록 해야 너무 많은 메소드가 생기는 것을 막을 수 있다.
   2. 여러 메소드에 중복적으로 보이는 패러미터들을 모아서 하나의 helper 클래스로 만들기. 당연하지만 inner static class으로 만드는게 좋다.
   3. 빌더 패턴 적용하기. 특히 패러미터 일부가 선택적으로 필요할 때 유용
4. 패러미터의 타입은 가급적 인터페이스로 지정
5. `boolean` 타입의 패러미터를 넣는 대신에 두 개의 요소를 갖는 enum 사용하기

## 오버로딩 적절하게 쓰기

오버로딩은 오버라이딩이랑 다르게 호출될 메소드가 컴파일 시점에 결정된다. 따라서 오버로딩을 마치 `switch`문 쓰듯이 쓰게 되면은 예상한 동작과 다른 결과물을 볼 수 있다. 실제 인스턴스가 어떤 것이냐에 상관없이 동작하기 때문이다. 그러므로 이 경우에는 오버로딩은 쓸 수 없고 직접 `instanceof` 를 사용해서 일일히 구분해줘야하게 된다. 

1. 같은 수의 패러미터를 가지는 2개 이상의 오버로딩 메소드를 만들지 않는다.
2. 어떤 메소드가 가변인자를 사용한다면 오버로딩하지 않는다.

=&gt; 위와 같은 경우에는 그냥 메소드 이름을 다르게 하는게 더 알아보기 쉽다.

생성자의 경우에는 메소드 이름을 다르게 할 수 없으므로 같은 패러미터 갯수를 가지는 생성자가 생길 수 밖에 없는데, 이 경우 서로 캐스팅이 안 되는 근본적으로 다른\(관계가 없는\) 타입들을 기준으로 해야된다.

그러나 하위호환같은 이유로 별 수 없이 서로 상속관계에 있는 두 클래스를 오버로딩 메소드의 패러미터로 각각 가질 수 있는데, 이 경우 좀 더 상세한 타입이 좀 더 추상적인 타입을 패러미터로 갖는 메소드를 재호출하도록 구현하면 언제 어떤 패러미터가 들어오더라도 동작을 보장할 수 있다.

