# 6장 - Enum, Annotation

## int 대신에 enum 쓰기

* 타입 안전이 보장된다
* 출력, 또는 디버깅할 때 어떤 값인지 쉽게 알아볼 수 있다
* 성능적으로 int를 사용하는 것과 비슷하다
  * 물론 메모리는 약간 더 먹긴 한다
* enum은 별개의 네임스페이스를 가지기 때문에 동일한 이름의 상수를 만드는데 지장이 없다
* enum에다가 별도의 메소드나 필드를 정의해서 좀 더 편리하게 사용할 수 있다
* enum에다가 abstract 메소드를 넣고 각각의 인스턴스마다 각자 구현한 다음 그 메소드를 호출하게끔 하여 switch-case문을 대체할 수 있다. 이 경우 enum의 요소가 늘어나더라도 switch-case의 case를 늘린다던가 하는 불편한 점이 없어진다.
  * 불필요하게 코드가 중복된다 싶으면 한 depth를 늘려서 중첩 enum을 만든 다음 거기에서 구현하게 하는 방법도 있다

## ordinal 대신에 인스턴스 필드 쓰기

ordinal을 사용하는 로직은 enum 인스턴스의 순서가 바뀌거나 새로운 요소를 추가할 때 문제를 일으킬 수 있음

## bit field 대신에 EnumSet 쓰기

* 비트 연산자를 쓰게 되면 알아보기 어렵고 각 요소를 차례대로 반복해서 처리할 방법이 없다
* EnumSet의 각 요소들은 내부적으로 bit vector으로 표현되며, 갯수가 64개 이하라면 전체가 하나의 long으로 처리된다. \(`RegularEnumSet`\)



